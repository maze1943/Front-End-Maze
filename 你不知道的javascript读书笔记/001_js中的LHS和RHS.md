# javascript中的LHS和RHS
#### 读书笔记----来自《你不知道的javascript》（上卷）第一章 作用域是什么

### javascript赋值操作的编译执行过程
javascript的赋值操作会在执行前进行编译，以这样一个声明为例：
`var a = 2;`
1. 编译器会先将这段程序分解成**词法单元**，然后将词法单元解析成“**抽象语法树**”（AST）
2. 当编译器生成可执行代码时，var a部分，编译器会询问作用域是否已经有一个该名称的变量存在，存在则忽略该声明，继续编译；否则会在当前作用域的集合中声明一个新的变量a；
3. 接下来编译器为引擎生成可运行的代码，引擎运行时会先询问作用域是否存在一个叫做a的变量，不存在会继续向上查找，直到找到该变量或到达作用域的顶端（全局作用域）；如果最终找到a，则将2赋值给他，否则抛出ReferenceError异常

### LHS和RHS
而编译器生成了由引擎执行的可执行代码后，在对变量进行查找的动作时，查找过程会由作用域进行协助。查找的方式有两种**LHS**和**RHS**：
“L”和“R”的含义是左和右，在这里表示赋值操作的左侧和右侧。实际上可以理解为LHS是**寻找赋值操作的目标**；而RHS则是**寻找变量的源值**;
以下面的代码片段为例：
```
function foo(a){
    var b = a;
    return a + b;
}
var c = foo(2);
```
这一段代码中就存在3个LHS查询，4个RHS查询。
1. 首先c被赋值，对c进行LHS引用；
2. c被赋予的值为foo(2)，需要查找foo(2)的值为多少，所以对foo(2)进行RHS引用；
3. 执行foo(2)时，隐形的执行了a = 2的操作，此时形参a被赋值，对a进行LHS引用；
4. var b = a中，b被赋值，进行LHS引用；而a需要RHS引用来查找其源值；
5. return a + b时，需要分别对a和b进行RHS引用查找源值；

### 为什么需要区分LHS和RHS
为什么区分LHS和RHS是有必要的呢？因为在变量还没有声明时（在任何作用域中都找不到该变量），这两种查询的行为是不一样的。如以下代码为例：
```
    function foo(a){
        console.log(a + b);
        b = a;
    }
    foo(2);
```
第一次对b进行RHS查询时，无法找到该变量，因为这是一个未经声明的变量，在任何作用域都找不到它。此时引擎会因为RHS在整个嵌套的作用域都找不到该变量，而抛出ReferenceError异常。
当引擎在非严格模式执行LHS查询时，如果整个作用域都找不到该变量，则会在全局作用域创建一个此变量的声明，并将其返回给引擎。但严格模式下不允许隐式的创建全局变量，会像RHS一样抛出ReferenceError。

接下来如果RHS查询找到了变量，但是尝试对其进行不合理操作，比如对非函数的值进行函数调用，或引用undefined或null的属性，引擎会抛出TypeError异常。